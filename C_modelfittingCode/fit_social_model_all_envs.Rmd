---
title: "Modelfitting"
author: "Simon&Andrea"
date: '2022-10-120'
output: html_document
---

```{r setup, include=FALSE}
pacman::p_load(tidyverse, rjson, DEoptim, doParallel, here,data.table)
knitr::opts_knit$set(root.dir = here()) # set root fot the whole file
```

In this document, we will fit a kalman filter to the "social bandit" task that Andrea and I developed. 
First, lets load some data.

```{r}
source("./C_modelfittingCode/models.R") # modelcode for fitting
source("./B_SimulationCode/load_environments.R") # environments
source("./B_SimulationCode/sim_models.R") # modelcode for simulation


# load behavioral data
#explore_data <- read_csv(file = paste0("./Data/data_coord.csv"))
social_data<-read_csv(file = paste0("./data/social/data_social_coord_schoolbactch_1.csv"))
social_data<-social_data%>%mutate(group=ifelse(player<16,"adults","kids"))%>%
  filter(tot_points>0)%>%filter(player<41)
# get na players and throw them out
filtered_players<-social_data%>%group_by(player)%>%
  dplyr::summarize(count_na = sum(is.na(cell)))%>%
  filter(count_na>0)%>%pull(player)

social_data<-social_data%>%filter(!(player %in% filtered_players))
```

# Fit model to social data
This function fits the model specified in models mle and stores the parameter estimates as well as the fit index (lower is better)
alongside the participant data in long format. In the future we want to modify this to fit different models


```{r}
cl <- parallel::makeCluster(40)
doParallel::registerDoParallel(cl)

source("./C_modelfittingCode/models_mle.R")
social_fits<-foreach(
  player_nr = unique(social_data$player),
  .packages = c("DEoptim", "dplyr"),
  .combine="rbind"
) %dopar% {
  
  #for(player_nr in unique(social_data$player)){
  Xnew <- as.matrix(expand.grid(0:7, 0:7)) # do this outside the loop for better speed
  
  # social data TODO: concatenate nonsocial data.
  d1 <- social_data%>%filter(player == player_nr) %>%
    group_by(round) %>%
    mutate(z = (points - 0) /100,
           social_info=social_info+1,
           choices=cells) %>%rowwise()%>%
    mutate(social_info=ifelse(social_info==65,64,social_info))%>%
    ungroup()
  
  
  rounds <- unique(d1$round)
  print(player_nr)
  #for (r in rounds) { # loop through rounds in roundList
  cv <- fit_fun(d1 = d1) # only try one sub
  # collect fit indices
  d1$fit<-unlist(cv[1])
  d1$lr<-unlist(cv[2])
  d1$tau<-unlist(cv[3])
  d1$soc_w<-unlist(cv[4])
  #d1$prior<-unlist(cv[5])
  
  #saveRDS(output, file = paste0("A_GeneratedFiles/modelfits/social_models/Q_fit", player_nr, ".rds"))
  return(d1)
}
```





# simulate
Here i take the dataframe from the previous modelfitting and simulate new responses
```{r}
random_G2s=-1*(log((1/64))*24*12)

#environment files are in generated files
environments<-load_envs(path="./A_GeneratedFiles/")
# ENVIRONMENTINDEXING FOR SIMS is 1:8

social_sims_plot_d<-foreach(
  player_nr = unique(social_fits$player),
  .packages = c("DEoptim", "dplyr"),
  .combine="rbind"
) %dopar% {
  # browser()
  #for(player_nr in unique(social_fits$player)){
    Xnew <- as.matrix(expand.grid(0:7, 0:7)) # do this outside the loop for better speed
    output <- c()
    
    # social data TODO: concatenate nonsocial data.
    d1 <- subset(social_fits, player == player_nr) %>%
      group_by(round) %>%
      mutate(z = (points - mean(points)) / sd(points),
             social_info=social_info+1,
             choices=cells) %>%rowwise()%>%
      mutate(social_info=ifelse(social_info==65,64,social_info))%>%
      ungroup()
    
    #### unpack parameters
    estimates<-c(
      unique(d1$lr),
      unique(d1$tau),
      unique(d1$soc_w)
    )
    ####
    #for (r in rounds) { # loop through rounds in roundList
    cv <- explore_env_social_fitted_pars(
      par = estimates, 
      learning_model_fun=RW_Q, 
      acquisition_fun=ucb,
      data = d1,
      envs=environments
    ) # only try one sub
    #collect fitted parameters and fit index and return
    #social_data$modelfit=cv
    #output <- rbind(output, cv)
    #}
    cv$player=player_nr
    cv$group=unique(d1$group)
  cv
}
```
  
  # dataframe
  
  ```{r}
  plot_df<-data.table::rbindlist(social_sims_plot_d, idcol = "index")
  
  
  social_fits%>%dplyr::group_by(trial,player,group)%>%filter(trial>0)%>%
    dplyr::summarise(m_rew=mean(points))%>%
    ggplot(aes(x=trial,y=m_rew,color=group))+
    #geom_line(aes(group=index))+
    stat_summary()
  
  
  social_fits%>%dplyr::group_by(trial,player,group,lr,soc_w)%>%filter(trial>0)%>%
    dplyr::summarise(m_rew=mean(points))%>%
    ggplot(aes(x=group,y=lr,color=group))+
    #geom_line(aes(group=index))+
    geom_boxplot()+
    theme_minimal()
  # higher social weight in kids
  social_fits%>%lm(data=.,soc_w~group)%>%anova()
  
  social_fits%>%dplyr::group_by(trial,player,group,lr,soc_w)%>%filter(trial>0)%>%
    dplyr::summarise(m_rew=mean(points))%>%
    ggplot(aes(x=group,y=soc_w,color=group))+
    #geom_line(aes(group=index))+
    geom_boxplot()+
    theme_minimal()
  #higher learningrate in kids
  social_fits%>%lm(data=.,lr~group)%>%anova()
  
  
  social_fits%>%dplyr::group_by(trial,player,group,lr,soc_w,tau)%>%filter(trial>0)%>%
    dplyr::summarise(m_rew=mean(points))%>%
    ggplot(aes(x=group,y=tau,color=group))+
    #geom_line(aes(group=index))+
    geom_boxplot()+
    theme_minimal()
  # no difference in tau
  social_fits%>%lm(data=.,tau~group)%>%anova()
  
  #hist(social_fits$soc_w)
  ```
  
  