---
title: "Modelfitting"
author: "Simon&Andrea"
date: '2022-10-120'
output: html_document
---

```{r setup, include=FALSE}
pacman::p_load(tidyverse, rjson, DEoptim, doParallel, here,data.table,jsonlite,lme4)
knitr::opts_knit$set(root.dir = here()) # set root fot the whole file
```

In this document, we will fit learning model to the "social bandit" task that Andrea and I developed. 
First, lets load some data.

```{r}

## load behavioral data
social_data <-  read_csv(file = paste0("./data/social/data_social_all_participants.csv"))


# total max min for range normalization
max_gem<-social_data%>%filter(gempresent==1)%>%pull(points)%>%max()
max_no_gem<-social_data%>%filter(gempresent==0)%>%pull(points)%>%max()
min<-social_data%>%pull(points)%>%min()


```

# Fit model to social data
This function fits the model specified in models_mle and stores the parameter estimates as well as the fit index (lower is better)
alongside the participant data in long format. In the future we want to modify this to fit different models

```{r}
# 
#cl <- makeCluster(detectCores()-8, type = 'PSOCK')
#registerDoParallel(cl)

## loads the script where the learning models are specified (Q-learning, social Q-learning, UCB etc)
source('./C_modelfittingCode/learning_models.R')

## load functions that perform Maximul Likelihood Estimation
source("./C_modelfittingCode/models_mle.R")

## load functions that initialize the model fit
source("./C_modelfittingCode/model_fitting_functions_social_bandits.R")
social_fits4 <- foreach(
  player_nr = unique(social_data$uniqueID),
  .packages = c("DEoptim", "dplyr"),
  .combine = "rbind"
) %dopar% {
  
  #for(player_nr in unique(social_data$player)){
  Xnew <- as.matrix(expand.grid(0:7, 0:7)) # do this outside the loop for better speed
  # social data TODO: concatenate nonsocial data.
  d1 <- social_data %>% filter(uniqueID == player_nr) %>%
    #filter(gempresent == 0) %>%  # for now only have rounds without gems 
    group_by(round) %>%
    mutate(z = points, #(points - mean(points)) / sd(points), ventually figure out what is the best outcome for this
           social_info = social_info,
           choices = cells
    ) %>% rowwise() %>%
    mutate(social_info = ifelse(social_info == 64, 1, social_info)) %>%
    ungroup()
  
  rounds <- unique(d1$round)
  
  #for (r in rounds) { # loop through rounds in roundList
  
  cv <- fit_range_adapt_lr(d1 = d1) # only try one sub
  
  # collect fit indices
  
  d1$fit <- unlist(cv[1])
  d1$lr_p <- unlist(cv[2])
  d1$sw <- unlist(cv[3])
  d1$tau <- unlist(cv[4])
  d1$tau_2<-unlist(cv[5])
  
  #d1$prior<-unlist(cv[5])
  
  return(d1)
}
saveRDS(social_fits4,file = "./A_GeneratedFiles/modelfits/range_norm_2tau_sutil.rds")
```

# Evaluate fit 


```{r}

social_fits %>%
  dplyr::select(uniqueID, group, fit) %>% 
  distinct() %>% 
  ggplot(aes(x = group, y = fit, color = group)) +
  #geom_line(aes(group=index))+
  stat_summary() +
  theme_minimal()

social_fits2 %>%
  dplyr::select(uniqueID, group, fit) %>% 
  distinct() %>% 
  ggplot(aes(x = group, y = fit, color = group)) +
  #geom_line(aes(group=index))+
  stat_summary() +
  theme_minimal()

social_fits3 %>%
  dplyr::select(uniqueID, group, fit) %>% 
  distinct() %>% 
  ggplot(aes(x = group, y = fit, color = group)) +
  #geom_line(aes(group=index))+
  stat_summary() +
  theme_minimal()

social_fits4 %>%
  dplyr::select(uniqueID, group, fit) %>% 
  distinct() %>% 
  ggplot(aes(x = group, y = fit, color = group)) +
  #geom_line(aes(group=index))+
  stat_summary() +
  theme_minimal()
```

```{r}
social_fits3 %>%
  dplyr::select(uniqueID, group, tau) %>% 
  distinct() %>% 
  ggplot(aes(x = group, y = tau, color = group)) +
  #geom_line(aes(group=index))+
  stat_summary() +
  theme_minimal()

social_fits3 %>%
  dplyr::select(uniqueID, group, tau_2) %>% 
  distinct() %>% 
  ggplot(aes(x = group, y = tau_2, color = group)) +
  #geom_line(aes(group=index))+
  stat_summary() +
  theme_minimal()


social_fits4 %>%
  dplyr::select(uniqueID, group, sw) %>% 
  distinct() %>% 
  ggplot(aes(x = group, y = sw, color = group)) +
  #geom_line(aes(group=index))+
  stat_summary() +
  theme_minimal()

social_fits4 %>%select(sw,group)%>%unique()%>% lm(sw~group,data=.)%>%anova()
```


simulate!

```{r}

random_G2s <-  -1 * (log((1 / 64)) * 24 * 4)

source("./B_SimulationCode/load_environments_social_experiment.R") # environments
source("./B_SimulationCode/sim_models.R") # modelcode for simulation

#environment files are in generated files
environments <- load_envs_social(path = "./A_GeneratedFiles/environments/")
social_sims_plot_d <- list()
social_sims_plot_one <- list()

i=1
for (rpt in 1){
  for (player_nr in unique(social_fits$uniqueID)) {
    Xnew <-
      as.matrix(expand.grid(0:7, 0:7)) # do this outside the loop for better speed
    print(player_nr)
    
    # social data TODO: concatenate nonsocial data.
    d1 <- social_fits3 %>% filter(uniqueID == player_nr) %>%
      group_by(round) %>%
      mutate(z = points,
             #(points - mean(points)) /sd(points),
             social_info = social_info,
             choices = cells) %>% rowwise() %>%
      mutate(social_info = ifelse(social_info == 64, 1, social_info)) %>%
      ungroup()
    
    #### unpack parameters
    estimates <- c(
      unique(d1$lr_p),
      unique(d1$sw),
      unique(d1$tau),
      unique(d1$tau_2)
    )
    ####
    cv <- sim_range_1lr_sws(
      par = estimates,
      learning_model_fun = RW_Q,
      acquisition_fun = ucb,
      data = d1,
      envs = environments
    ) # only try one sub
    
    cv$player = player_nr
    cv$group = unique(d1$group)
    cv$run = rpt
    social_sims_plot_one[[i]] <- cv
    i = i+1
  }
  social_sims_plot_d[[rpt]] <- do.call("rbind", social_sims_plot_one)
}
#}

social_sims_plot_dhuge <- do.call("rbind", social_sims_plot_d)
```

```{r}

gem<-environments%>%group_by(env)%>%
  summarise(gem=mean(gems))%>%arrange(env)%>%
  pull(gem)

social_sims_plot_dhuge<-social_sims_plot_dhuge %>%mutate(gem=ifelse(env_idx>4,1,0))%>%
  mutate(uniqueID=player)

social_sims_plot_dhuge %>% mutate(gem=ifelse(env_idx>4,1,0))%>%
  mutate(uniqueID=player)%>%
  dplyr::group_by(trial, player, group,gem) %>%
  filter(trial > 0) %>%
  #filter(group!="adults")%>%
  dplyr::summarise(m_rew = mean(z))%>%mutate(pats_or_sim="sims")->sims

social_fits %>%filter(!is.na(env_number))%>%mutate(gem=ifelse(env_number>4,1,0),group=group)%>%
  dplyr::group_by(trial, uniqueID,gem,group) %>%
  filter(trial > 0) %>% #filter(group!="adults")%>%
  dplyr::summarise(m_rew = mean(points)) %>%mutate(pats_or_sim="pats")->pats

what_is_this<-left_join(social_sims_plot_dhuge,social_fits,by=c("uniqueID","trial","round","group"))

simsub_dat<-rbind(sims,pats)

#cowplot::plot_grid(sims, ppts)

simsub_dat%>%
  ggplot(aes(x = trial, y = m_rew, color = group,linetype=pats_or_sim)) +
  ggtitle("Simulations") +
  stat_summary() +
  stat_smooth(method = "lm") +
  facet_wrap(pats_or_sim~gem)+
  theme_bw() #-> comp_plot

what_is_this%>%ggplot(aes(x=trial,y =points, color = group)) +
  ggtitle("Participants") +
   stat_summary() +
  coord_cartesian(ylim=c(0,200))+
  scale_color_discrete(name="Agegroup")+
  facet_grid(demo_quality.y~gemlabel)+
  theme_bw()

what_is_this%>%ggplot(aes(x=trial,y =z.x, color = group)) +
  ggtitle("Participants") +
   stat_summary() +
  coord_cartesian(ylim=c(0,200))+
  scale_color_discrete(name="Agegroup")+
  facet_grid(demo_quality.y~gemlabel)+
  theme_bw()


```



